// ========================= USER INPUTS ====================================================================================
//-------------------------- Bounding Box of AOI-----------------------------------------------------------------------------
// area of interest - user input
//var AOI = [15,-35.3,33.4,-22.1]; //(lonmin, latmin, lonmax, latmax)
var AOI = [27.1094797179,-25.8244106323,27.690106954,-25.5378981131]
//-------------------------- Viewer time of Interest-------------------------------------------------------------------------
//var startTime = new Date().toISOString();  // in SAST
var startTime = "2017-11-28T16:30:00+00:00";
//var endTime = "2017-11-29T16:30:00+00:00";
var endTime = "2017-11-28T18:00:00+00:00";
// --------------------------Cube height ------------------------------------------------------------------------------------
//var cube_height = 600000; // extruded height of the space time cube; a visual effect
var cube_height = 10000;
var usr_color = Cesium.Color.DEEPPINK;
//========================== HELPER FUNCTIONS ===============================================================================
// -------------------------1. Rectangle depicting AOI ----------------------------------------------------------------------
//var aoiRectangle = Cesium.Rectangle.fromDegrees(15,-35.3,33.4,-22.1); //(lonmin, latmin, lonmax, latmax)
var aoiRectangle = Cesium.Rectangle.fromDegrees(27.1094797179,-25.8244106323,27.690106954,-25.5378981131)
//--------------------------2. Calculate the time interval per bin ----------------------------------------------------------
var tot_time_diff = Math.floor((Math.abs(Date.parse(endTime) - Date.parse(startTime))/1000)/60); // time difference in minutes
var h_interval = 10 // hieght of each bin on the z-axis
var time_interval_bin = tot_time_diff/h_interval;

// =========================== VIEWER SETUP =================================================================================
// --------------------------------------------------------------------------------------------------------------------------
Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI4ODE4OGQwNy1iZDZkLTRlZTEtYTVjMy1mMWU0MThkNzZkMWYiLCJpZCI6MzQ1MSwiaWF0IjoxNTM3NTMzOTc0fQ.SYqvJaxMNYQ8a8_0InUYPw8c3tE_mqcFs3sxCOp3Ukw';
var mapprojection = new Cesium.WebMercatorProjection(Cesium.Ellipsoid.WGS84)
var viewer = new Cesium.Viewer('cesiumContainer', {
    terrainProvider: Cesium.createWorldTerrain(),
    mapProjection: mapprojection
});

viewer.scene.globe.cartographicLimitRectangle = aoiRectangle;
viewer.scene.globe.showSkirts = false;
viewer.scene.skyAtmosphere.show = false;

viewer.camera.flyTo({
    destination : aoiRectangle
});

// space time cube outline
var stcOutline = viewer.entities.add({
    name: 'space time cube',
    polygon : {
        hierarchy : Cesium.Cartesian3.fromDegreesArrayHeights([AOI[0], AOI[3], cube_height,
                                                        AOI[2], AOI[3], cube_height,
                                                        AOI[2], AOI[1], cube_height,
                                                        AOI[0], AOI[1], cube_height]),
        extrudedHeight: 0, //user input
        perPositionHeight : true,
        material : Cesium.Color.FLORALWHITE.withAlpha(0),
        outline : true,
        outlineColor : Cesium.Color.FLORALWHITE,
        arcType : Cesium.ArcType.RHUMB
    }
});
//=====================================================================================================================

// ========================== DATA ====================================================================================
// --------------------------reading from websocket -------------------------------------------------------------------
// --------------------------------------------------------------------------------------------------------------------
// --------------------------reading from a json object generated by an external algorithm ----------------------------
// read data from JSON 
let requestURL = '../data/results/enl_concom_result.json'
let request = new XMLHttpRequest();
request.open('GET', requestURL);
request.responseType = 'json';
request.send();
request.onload = function(){
    //------------------------- HELPER FUNCTION -----------------------------------------------------------------------
    //------------------------- 3. Style function ---------------------------------------------------------------------
    /* style is a function of time in the case of existence 
    where age is show with color intesity - a faded color implies an event that has already passed but lies within
    the users view time of interest 
    */
    /*function style(time){
        console.log('style function called');
        //console.log(czml.length);
        console.log(time);
        var alpha ;
        if(time===startTime){
            alpha = 255;
        }else{
            alpha = ((Date.parse(time) - Date.parse(startTime))/(Date.parse(endTime)-Date.parse(startTime)))*255;
        };
        console.log(alpha);
        var rgba = [usr_color.red*100, usr_color.green*100, usr_color.blue*100, alpha];
        var new_color = {
            "interval": interval,
            "rgba" : rgba // will create new style for current object and update previous observations
        }
        el.polygon.material.solidColor.color.push(new_color);
        return material;
        // update the style of all previous observations
        // age of the event - alpha
        /* the age of the event describes how long ago the event took place - in relation to the viewers time of interest */
        /*if(czml.length > 1){
            for(var i=1; i<czml.length; i++){
                var alpha;
                var el = czml[i];
                console.log(time);
                if(time === startTime){
                    alpha = 255;
                }else{
                    alpha = ((Date.parse(el.observationTime) - Date.parse(startTime))/(Date.parse(time)-Date.parse(startTime)))*255;
                };
                console.log(alpha);
                
                var rgba = [usr_color.red*100, usr_color.green*100, usr_color.blue*100, alpha];
                czml[i].polygon.material.solidColor.color.rgba = rgba;
            };
        };
        var rgba = [usr_color.red*100, usr_color.green*100, usr_color.blue*100, 255];
        return rgba;
    };*/

    function createStyle(time){
        console.log('style function called');
        // update the style of all previous observations
        // age of the event - alpha
        /* the age of the event describes how long ago the event took place - in relation to the viewers time of interest */
        if(czml.length > 1){
            for(var i=1; i<czml.length; i++){
                var alpha;
                var el = czml[i];
                var interval = time + "/" + endTime;
                //console.log(time);
                //console.log(el);
                if(time === startTime){
                    alpha = 255;
                }else{
                    alpha = ((Date.parse(el.observationTime) - Date.parse(startTime))/(Date.parse(time)-Date.parse(startTime)))*255;
                };
                //console.log(alpha);
                
                var rgba = [usr_color.red*100, usr_color.green*100, usr_color.blue*100, alpha];
                // push the color back into czml
                var new_color = {
                    "interval" : interval,
                    "rgba" : rgba 
                }; 
                czml[i].polygon.material.solidColor.color.push(new_color);
            };
        };
    };
    //=================================================================================================================


    //=============================================================================================
    // -----------------------------using CZML to show dynamic time based animations --------------

    // czml to be loaded dynamically as data becomes available
    // for more in CZML - https://github.com/AnalyticalGraphicsInc/czml-writer/wiki/CZML-Structure
    var czml = [
        {
        "id" : "document",
        "name" : "CZML ENL Clusters",
        "version" : "1.0"
        }
    ];

    function createCZML(i, id, coords, height, time){
        var t0 = startTime; 
        var tn = endTime;
        var ti = time;
        var interval = ti + "/" +tn;
        var colr = Cesium.Color.fromRandom({alpha : 0.5});
        czmlpacket = {
            "id" : id.toString()+"_"+i,
            "name": id.toString(),
            "observationTime": ti,
            "availability": t0 + "/" +tn,
            "polygon": {
                "positions" : {
                    "interval": interval,
                    "cartographicDegrees" : coords.flat(1)
                }, 
                "propertylabel" : {
                    "propertyValue" : id,
                    "property": "cluster_polygon"
                },
                "material" : {
                    "solidColor" : {
                        "color" : []
                    }
                },
                "outline" : true,
                "outlineColor" : {
                    "rgba" : [0, 0, 0, 255]
                },
                "perPositionHeight" : true,
                "extrudedHeight": height - 1000
            },
        };
        // push packet into the czml document-object
        czml.push(czmlpacket); 
        console.log(czml); 
    }

    // create the czml data source 
    var czmlDataSource = new Cesium.CzmlDataSource();
    //viewer.dataSources.add(czmlDataSource);

    /*function updateCZML(){
        
        // load the czml object 
        console.log('--------czml----------');
        console.log(czml);
        //var czmlDataSource = new Cesium.CzmlDataSource();
        viewer.dataSources.remove(czmlDataSource);
        czmlDataSource.load(czml);
        viewer.dataSources.add(czmlDataSource);
        viewer.zoomTo(czmlDataSource.entities);
    }*/

    // ===========================================================================================
    // --------------------------if we use GeoJSON ----------------------------------------------

    // define geojson source
    var jsnSource = new Cesium.GeoJsonDataSource("enl_clusters");

    // add source to view
    // viewer.dataSources.add(jsnSource);

    // feature to be loaded on the cube; it gets updated with data later
    // for geojson https://tools.ietf.org/html/rfc7946
    var features = [];
    var jsnObj = {"type":"FeatureCollection", "features":features};

    // create geojson feature
    function createGeoJSON(poly_coords, id, time){
        var feature = {"type": "Feature", "geometry" :{"type":"Polygon", "coordinates": [poly_coords]}, "properties": {"name": id, "time": time}};
                // push polygon feature into feature array
                if(poly_coords.length > 3){
                features.push(feature);  
        }
        return feature;
    }

    // load geojson to cube
    function loadCube(jsnobj){
        jsnSource.load(jsnobj, {
            stroke: Cesium.Color.HOTPINK,
            fill: Cesium.Color.PINK.withAlpha(0.5),
            strokeWidth: 5,
            clampToGround: true
        });
    };

    function gjsontoViewer(jsnobj){
        // update cesium cube  
        // console.log(jsnObj);
        // add source to view
        viewer.dataSources.add(jsnSource);
        viewer.zoomTo(jsnSource.entities);
        console.log(jsnobj);
    }
    //==============================================================================================

    //======================================= REQUEST RESPONSE ======================================================
    const data = request.response;
    results =  data.result;
    // console.log(results);
    var time_list=[];
    for(i=0; i<results.length; i++) {
        el=results[i];
        console.log('---i----');
        //console.log(i);
        //console.log(el);
        var id = el.cluster_label;
        // get cluster time 
        var time = el.cluster_time;
        time_list.push(time);
        //console.log(time_list);
        //var h = (100*(i+1)); // Height is a function of time and extruded height F(eh, t)
        //h += 10; // the height
        //var h_in_bin = (Math.floor(Date.parse(time) - Date.parse(startTime))/1000)/time_interval_bin;
        //var h = h_in_bin * h_interval;
        curr_time_diff = Math.floor((Math.abs(Date.parse(time) - Date.parse(startTime))/1000)/60)
        //console.log(curr_time_diff);
        h =cube_height * (curr_time_diff/tot_time_diff);
        console.log(h);
        //console.log(h);
        // load cluster polygon into geojson feature
        // make coordinates 3 dimensional
        var coords = (el.cluster_polygon);
        //console.log(coords.length);
        var poly_coords =[];
        if(coords.length > 0){
            for(j=0; j< coords.length; j++){
                _coords = coords[j];
                x_mercator = _coords[0];
                y_mercator = _coords[1];
                
                var cartObj = mapprojection.unproject(new Cesium.Cartesian3(x_mercator, y_mercator, h));
                cs_coords = [Cesium.Math.toDegrees(cartObj.longitude), Cesium.Math.toDegrees(cartObj.latitude), h/*Cesium.Math.toDegrees(cartObj.height)*/]
                //console.log(cs_coords); 
                poly_coords.push(cs_coords); 
            };
            // using CZML - create czml packets
            //console.log(poly_coords.flat(1));
            //createCZML(i, id, poly_coords, h,time);
            //updateCZML(); // need to redraw everytime a new object arrives 
            createCZML(i, id, poly_coords, h,time); 
            //console.log('-------draw---------------');
            //console.log(JSON.stringify(czml));
            createStyle(time);

        }
           
    }
    //console.log(JSON.stringify(czml));
    czmlDataSource.load(czml);
    viewer.dataSources.add(czmlDataSource);
    viewer.zoomTo(czmlDataSource.entities);
    
    // using czml load to viewer     
    // OR if using geojson - no time animation yet
    //createGeoJSON(poly_coords, id, time) 
    //updateCZML();
    
    // OR if using geojson - no time animation yet
    //loadCube(jsnObj);
    //gjsontoViewer(jsnObj)
    
}